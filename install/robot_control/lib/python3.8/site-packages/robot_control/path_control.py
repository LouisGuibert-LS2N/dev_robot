import rclpy
from rclpy.node import Node

from sensor_msgs.msg import LaserScan

from std_msgs.msg import Int16MultiArray


class PathControl(Node):
    def __init__(self):
        super().__init__('path_controller')
        # minimal value in meter on left & right
        self.minimal_value_left = 2.5
        self.minimal_value_right = 2.5

        # motors speed
        self.cruise_speed = 100

        self.motor_speed = [int] * 2
        # left
        self.motor_speed[0] = 0
        # right
        self.motor_speed[1] = 0

        # publishing part
        self.publisher_ = self.create_publisher(Int16MultiArray, 'motor_command', 10)

        # subscribing part
        self.subscription = self.create_subscription(
            LaserScan,
            'scan',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        print("reading data..")
        # nb msg ranges = 1080 for 360°
        # so angle increment is 1/3 °
        # so 1° = 3 msg ranges
        # 1080 - 60 * 3 = 900
        # print('distance -60°(left) :%f' % msg.ranges[180])
        # print('distance 0° (front) :%f' % msg.ranges[0])
        # 60 * 3 = 180
        # print('distance +60° (right) :%f' % msg.ranges[900])

        # to change motor speed the priority is FRONT > RIGHT > LEFT > CRUISE
        self.motor_speed[0] = self.cruise_speed
        self.motor_speed[1] = self.cruise_speed

        # LEFT, motor right speed depend on the closest distance between something
        # get the closest distance between something
        # between 20° to 60° so 20*2=40+1 to 60*2=120
        tab_left = []
        for i in range(41, 120):
            tab_left.append(msg.ranges[i])
        min_left = min(tab_left)

        print('Minimal value on the left :%f' % min_left)
        # speed change only bellow 2.5 meter
        if min_left < self.minimal_value_left:
            # 100 is the regular speed
            # motor left
            self.motor_speed[0] = self.cruise_speed
            # motor right, 100 when 2.5 meter, 50 at 1.5 meter, 0 at 0.5 meter, below it stop
            self.motor_speed[1] = (self.cruise_speed / 2) * min_left - (self.cruise_speed / 4)

        # RIGHT, motor right speed depend on the closest distance between something
        # get the closest distance between something
        # between -60° to -20° so 1080-60*2=960 to 1080-20*2=1040 -1
        tab_right = []
        for i in range(960, 1040):
            tab_right.append(msg.ranges[i])
        min_right = min(tab_right)

        print('Minimal value on the right :%f' % min_right)
        # speed change only bellow 2.5 meter
        if min_right < self.minimal_value_right:
            # 100 is the regular speed
            # motor left, 100 when 2.5 meter, 50 at 1.5 meter, 0 at 0.5 meter, below it stop
            self.motor_speed[0] = (self.cruise_speed / 2) * min_right - (self.cruise_speed / 4)
            # motor right
            self.motor_speed[1] = self.cruise_speed

        # FRONT < 1 meter => stop the motor
        # -20° to 20° => 1080-20*2 = 1040 to 20*2 = 40
        # so 1040 to 1080 and 0 to 40
        for i in range(1040, 1080):
            if msg.ranges[i] < 1:
                self.motor_speed[0] = 0
                self.motor_speed[1] = 0
                break

        for i in range(0, 40):
            if msg.ranges[i] < 1:
                self.motor_speed[0] = 0
                self.motor_speed[1] = 0
                break

        self.data_sending()

    def data_sending(self):
        msg = Int16MultiArray()
        msg.data = [int(self.motor_speed[0]), int(self.motor_speed[1])]

        self.publisher_.publish(msg)
        print('Publishing data: left:%s right:%s' % (msg.data[0], msg.data[1]))


def main(args=None):
    rclpy.init(args=args)
    path_controller = PathControl()
    print("Path_control launch")
    rclpy.spin(path_controller)

    path_controller.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
